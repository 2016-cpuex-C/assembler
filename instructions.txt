000001  move    r r
000010  neg     r r
000011  add     r r r
000100  addi    r r i
000101  sub     r r r
000110  subi    r r i
000111 -mult    r r r
001000 -multi   r r i
001001 -div     r r r
001010 -divi    r r i
001011  mov.s   f f
001100  neg.s   f f
001101  add.s   f f f
001110  sub.s   f f f
001111  mul.s   f f f
010000  div.s   f f f
010001  srl     r r i
010010  sll     r r i
010011  li      r i
010100  la      r li
010101  lwl     r lf
010110  lwr     r r i
010111  l.sl    f lf
011000  l.sr    f r i
011001  sw      r r i
011010  s.s     f r i
011011  beq     r r li
011100  bne     r r li
011101  blt     r r li
011110  bgt     r r li
011111  c.eq.s  f f li
100000  c.le.s  f f li
100001  c.lt.s  f f li
100010  j       li
100011  jr      r
100100  jal     li
100101  jalr    r
100110  print_i r
100111 -print_f f
101000  print_c r
101001  read_i  r
101010  read_f  f
101011  sin     f f
101100  cos     f f
101101  atan    f f
101110 -floor   f f
101111 -sqrt    f f
110000 -ftoi    r f
110001 -itof    f r
110010  exit
110011  print_b r

============================================

+ 行番号がopcodeに対応(1始まり)

+ 先頭に-付きは優先度低

+ 幅は
    opcode  6
    r       5
    f       5
    i       16

+ 余ったbitはdon't care

+ intの掛け算
  mult r1 r2
  mflo r3
の代わりに
  mult r3 r1 r2
を使う

+ labelは2種類ある(float定数用, jump用)のでそれぞれlf,liと書き分けてます.

+ 即値はsigned short, labelはunsigend short

+ mipsだとb系は相対ジャンプ, j系は絶対ジャンプと決まってるけど全部絶対ジャンプにします(2^16=65536あれば十分のはず)

+ レジスタ

    00 00000 $zero
    01 00001 $at
    02 00010 $v0
    03 00011 $v1
    04 00100 $a0
    05 00101 $a1
    06 00110 $a2
    07 00111 $a3
    08 01000 $t0
    09 01001 $t1
    10 01010 $t2
    11 01011 $t3
    12 01100 $t4
    13 01101 $t5
    14 01110 $t6
    15 01111 $t7
    16 10000 $s0
    17 10001 $s1
    18 10010 $s2
    19 10011 $s3
    20 10100 $s4
    21 10101 $s5
    22 10110 $s6
    23 10111 $s7
    24 11000 $t8
    25 11001 $t9
    26 11010 $k0
    27 11011 $k1
    28 11100 $gp
    29 11101 $sp
    30 11110 $fp
    31 11111 $ra

